
PANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 56ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 12ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 10ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774761ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@593e685
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43311984
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1359
============ parsing ============
total                         = 601
file parser                   = 486
sort expansion                = 66
closed world assumption       = 27
inherit preconditions         = 0
shop methods                  = 3
eliminate identical variables = 4
strip domain of hybridity     = 1
flatten formula               = 11
============ preprocessing ============
total                                      = 380
compile negative preconditions             = 18
compile unit methods                       = 0
split parameter                            = 14
expand choiceless abstract tasks           = 31
compile methods with identical tasks       = 0
removing unnecessary predicates            = 31
lifted reachabiltiy analysis               = 0
grounded planning graph analysis           = 150
grounded task decomposition graph analysis = 74
grounding                                  = 41
create artificial top task                 = 6
============ heuristics preparation ============
total = 2
============ search preparation ============
compute efficient representation = 84
============ search ============
total             = 178
flaw estimation   = 65
flaw computation  = 13
flaw selector     = 5
compute heuristic = 33
compute filter    = 0

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43311984";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="486";"01 parsing:08:flatten formula"="11";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="1";"02 preprocessing:08:removing unnecessary predicates"="31";"01 parsing:03:closed world assumption"="27";"02 preprocessing:11:lifted reachabiltiy analysis"="0";"01 parsing:02:sort expansion"="66";"20 search:40:compute heuristic"="33";"01 parsing:00:total"="601";"20 search:10:flaw selector"="5";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="0";"02 preprocessing:01:compile negative preconditions"="18";"20 search:00:total"="178";"00 total:00:total"="1359";"02 preprocessing:12:grounded planning graph analysis"="150";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="74";"20 search:01:flaw estimation"="65";"02 preprocessing:04:split parameter"="14";"01 parsing:05:shop methods"="3";"20 search:02:flaw computation"="13";"10 search preparation:01:compute efficient representation"="84";"01 parsing:06:eliminate identical variables"="4";"02 preprocessing:05:expand choiceless abstract tasks"="31";"03 heuristics preparation:00:total"="2";"02 preprocessing:00:total"="380";"02 preprocessing:99:create artificial top task"="6";"02 preprocessing:84:grounding"="41"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackage1PANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 50ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 15ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 9ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774812ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@5b746e22
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43326168
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1250
============ parsing ============
total                         = 565
file parser                   = 443
sort expansion                = 68
closed world assumption       = 28
inherit preconditions         = 0
shop methods                  = 4
eliminate identical variables = 4
strip domain of hybridity     = 1
flatten formula               = 15
============ preprocessing ============
total                                      = 392
compile negative preconditions             = 27
compile unit methods                       = 0
split parameter                            = 17
expand choiceless abstract tasks           = 31
compile methods with identical tasks       = 0
removing unnecessary predicates            = 35
lifted reachabiltiy analysis               = 0
grounded planning graph analysis           = 147
grounded task decomposition graph analysis = 72
grounding                                  = 49
create artificial top task                 = 4
============ heuristics preparation ============
total = 1
============ search preparation ============
compute efficient representation = 69
============ search ============
total             = 146
flaw estimation   = 52
flaw computation  = 15
flaw selector     = 2
compute heuristic = 36
compute filter    = 1

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43326168";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="443";"01 parsing:08:flatten formula"="15";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="1";"02 preprocessing:08:removing unnecessary predicates"="35";"01 parsing:03:closed world assumption"="28";"02 preprocessing:11:lifted reachabiltiy analysis"="0";"01 parsing:02:sort expansion"="68";"20 search:40:compute heuristic"="36";"01 parsing:00:total"="565";"20 search:10:flaw selector"="2";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="1";"02 preprocessing:01:compile negative preconditions"="27";"20 search:00:total"="146";"00 total:00:total"="1250";"02 preprocessing:12:grounded planning graph analysis"="147";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="72";"20 search:01:flaw estimation"="52";"02 preprocessing:04:split parameter"="17";"01 parsing:05:shop methods"="4";"20 search:02:flaw computation"="15";"10 search preparation:01:compute efficient representation"="69";"01 parsing:06:eliminate identical variables"="4";"02 preprocessing:05:expand choiceless abstract tasks"="31";"03 heuristics preparation:00:total"="1";"02 preprocessing:00:total"="392";"02 preprocessing:99:create artificial top task"="4";"02 preprocessing:84:grounding"="49"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackage1PANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 51ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 14ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 8ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774842ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@4739b68b
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43308744
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1239
============ parsing ============
total                         = 559
file parser                   = 449
sort expansion                = 63
closed world assumption       = 25
inherit preconditions         = 0
shop methods                  = 3
eliminate identical variables = 5
strip domain of hybridity     = 1
flatten formula               = 12
============ preprocessing ============
total                                      = 369
compile negative preconditions             = 17
compile unit methods                       = 0
split parameter                            = 13
expand choiceless abstract tasks           = 27
compile methods with identical tasks       = 0
removing unnecessary predicates            = 35
lifted reachabiltiy analysis               = 0
grounded planning graph analysis           = 152
grounded task decomposition graph analysis = 75
grounding                                  = 38
create artificial top task                 = 3
============ heuristics preparation ============
total = 0
============ search preparation ============
compute efficient representation = 70
============ search ============
total             = 165
flaw estimation   = 55
flaw computation  = 15
flaw selector     = 2
compute heuristic = 45
compute filter    = 0

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43308744";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="449";"01 parsing:08:flatten formula"="12";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="1";"02 preprocessing:08:removing unnecessary predicates"="35";"01 parsing:03:closed world assumption"="25";"02 preprocessing:11:lifted reachabiltiy analysis"="0";"01 parsing:02:sort expansion"="63";"20 search:40:compute heuristic"="45";"01 parsing:00:total"="559";"20 search:10:flaw selector"="2";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="0";"02 preprocessing:01:compile negative preconditions"="17";"20 search:00:total"="165";"00 total:00:total"="1239";"02 preprocessing:12:grounded planning graph analysis"="152";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="75";"20 search:01:flaw estimation"="55";"02 preprocessing:04:split parameter"="13";"01 parsing:05:shop methods"="3";"20 search:02:flaw computation"="15";"10 search preparation:01:compute efficient representation"="70";"01 parsing:06:eliminate identical variables"="5";"02 preprocessing:05:expand choiceless abstract tasks"="27";"03 heuristics preparation:00:total"="0";"02 preprocessing:00:total"="369";"02 preprocessing:99:create artificial top task"="3";"02 preprocessing:84:grounding"="38"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackage1PANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 47ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 18ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 8ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774889ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@4739b68b
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43315376
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1208
============ parsing ============
total                         = 503
file parser                   = 385
sort expansion                = 70
closed world assumption       = 26
inherit preconditions         = 0
shop methods                  = 3
eliminate identical variables = 5
strip domain of hybridity     = 2
flatten formula               = 12
============ preprocessing ============
total                                      = 377
compile negative preconditions             = 22
compile unit methods                       = 0
split parameter                            = 23
expand choiceless abstract tasks           = 24
compile methods with identical tasks       = 0
removing unnecessary predicates            = 32
lifted reachabiltiy analysis               = 0
grounded planning graph analysis           = 141
grounded task decomposition graph analysis = 71
grounding                                  = 48
create artificial top task                 = 4
============ heuristics preparation ============
total = 0
============ search preparation ============
compute efficient representation = 73
============ search ============
total             = 174
flaw estimation   = 60
flaw computation  = 20
flaw selector     = 3
compute heuristic = 42
compute filter    = 0

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43315376";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="385";"01 parsing:08:flatten formula"="12";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="2";"02 preprocessing:08:removing unnecessary predicates"="32";"01 parsing:03:closed world assumption"="26";"02 preprocessing:11:lifted reachabiltiy analysis"="0";"01 parsing:02:sort expansion"="70";"20 search:40:compute heuristic"="42";"01 parsing:00:total"="503";"20 search:10:flaw selector"="3";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="0";"02 preprocessing:01:compile negative preconditions"="22";"20 search:00:total"="174";"00 total:00:total"="1208";"02 preprocessing:12:grounded planning graph analysis"="141";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="71";"20 search:01:flaw estimation"="60";"02 preprocessing:04:split parameter"="23";"01 parsing:05:shop methods"="3";"20 search:02:flaw computation"="20";"10 search preparation:01:compute efficient representation"="73";"01 parsing:06:eliminate identical variables"="5";"02 preprocessing:05:expand choiceless abstract tasks"="24";"03 heuristics preparation:00:total"="0";"02 preprocessing:00:total"="377";"02 preprocessing:99:create artificial top task"="4";"02 preprocessing:84:grounding"="48"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackage1PANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 47ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 13ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 7ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774809ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@66cb5d10
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43305720
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1252
============ parsing ============
total                         = 595
file parser                   = 472
sort expansion                = 65
closed world assumption       = 31
inherit preconditions         = 0
shop methods                  = 4
eliminate identical variables = 5
strip domain of hybridity     = 1
flatten formula               = 16
============ preprocessing ============
total                                      = 367
compile negative preconditions             = 24
compile unit methods                       = 0
split parameter                            = 15
expand choiceless abstract tasks           = 21
compile methods with identical tasks       = 0
removing unnecessary predicates            = 35
lifted reachabiltiy analysis               = 1
grounded planning graph analysis           = 138
grounded task decomposition graph analysis = 68
grounding                                  = 49
create artificial top task                 = 4
============ heuristics preparation ============
total = 1
============ search preparation ============
compute efficient representation = 67
============ search ============
total             = 148
flaw estimation   = 43
flaw computation  = 11
flaw selector     = 2
compute heuristic = 42
compute filter    = 0

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43305720";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="472";"01 parsing:08:flatten formula"="16";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="1";"02 preprocessing:08:removing unnecessary predicates"="35";"01 parsing:03:closed world assumption"="31";"02 preprocessing:11:lifted reachabiltiy analysis"="1";"01 parsing:02:sort expansion"="65";"20 search:40:compute heuristic"="42";"01 parsing:00:total"="595";"20 search:10:flaw selector"="2";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="0";"02 preprocessing:01:compile negative preconditions"="24";"20 search:00:total"="148";"00 total:00:total"="1252";"02 preprocessing:12:grounded planning graph analysis"="138";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="68";"20 search:01:flaw estimation"="43";"02 preprocessing:04:split parameter"="15";"01 parsing:05:shop methods"="4";"20 search:02:flaw computation"="11";"10 search preparation:01:compute efficient representation"="67";"01 parsing:06:eliminate identical variables"="5";"02 preprocessing:05:expand choiceless abstract tasks"="21";"03 heuristics preparation:00:total"="1";"02 preprocessing:00:total"="367";"02 preprocessing:99:create artificial top task"="4";"02 preprocessing:84:grounding"="49"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackage1PANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 47ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 17ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 8ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774902ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@4bd5d645
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43279784
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1153
============ parsing ============
total                         = 526
file parser                   = 418
sort expansion                = 59
closed world assumption       = 28
inherit preconditions         = 0
shop methods                  = 2
eliminate identical variables = 5
strip domain of hybridity     = 2
flatten formula               = 12
============ preprocessing ============
total                                      = 342
compile negative preconditions             = 19
compile unit methods                       = 0
split parameter                            = 14
expand choiceless abstract tasks           = 22
compile methods with identical tasks       = 0
removing unnecessary predicates            = 31
lifted reachabiltiy analysis               = 0
grounded planning graph analysis           = 140
grounded task decomposition graph analysis = 65
grounding                                  = 37
create artificial top task                 = 4
============ heuristics preparation ============
total = 1
============ search preparation ============
compute efficient representation = 69
============ search ============
total             = 139
flaw estimation   = 42
flaw computation  = 14
flaw selector     = 0
compute heuristic = 38
compute filter    = 0

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43279784";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="418";"01 parsing:08:flatten formula"="12";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="2";"02 preprocessing:08:removing unnecessary predicates"="31";"01 parsing:03:closed world assumption"="28";"02 preprocessing:11:lifted reachabiltiy analysis"="0";"01 parsing:02:sort expansion"="59";"20 search:40:compute heuristic"="38";"01 parsing:00:total"="526";"20 search:10:flaw selector"="0";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="0";"02 preprocessing:01:compile negative preconditions"="19";"20 search:00:total"="139";"00 total:00:total"="1153";"02 preprocessing:12:grounded planning graph analysis"="140";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="65";"20 search:01:flaw estimation"="42";"02 preprocessing:04:split parameter"="14";"01 parsing:05:shop methods"="2";"20 search:02:flaw computation"="14";"10 search preparation:01:compute efficient representation"="69";"01 parsing:06:eliminate identical variables"="5";"02 preprocessing:05:expand choiceless abstract tasks"="22";"03 heuristics preparation:00:total"="1";"02 preprocessing:00:total"="342";"02 preprocessing:99:create artificial top task"="4";"02 preprocessing:84:grounding"="37"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackage1PANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 42ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 13ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 8ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774859ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@4739b68b
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43306040
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1345
============ parsing ============
total                         = 555
file parser                   = 441
sort expansion                = 67
closed world assumption       = 26
inherit preconditions         = 0
shop methods                  = 3
eliminate identical variables = 5
strip domain of hybridity     = 1
flatten formula               = 12
============ preprocessing ============
total                                      = 343
compile negative preconditions             = 19
compile unit methods                       = 0
split parameter                            = 14
expand choiceless abstract tasks           = 31
compile methods with identical tasks       = 0
removing unnecessary predicates            = 31
lifted reachabiltiy analysis               = 1
grounded planning graph analysis           = 132
grounded task decomposition graph analysis = 65
grounding                                  = 37
create artificial top task                 = 4
============ heuristics preparation ============
total = 1
============ search preparation ============
compute efficient representation = 113
============ search ============
total             = 217
flaw estimation   = 74
flaw computation  = 19
flaw selector     = 2
compute heuristic = 54
compute filter    = 0

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43306040";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="441";"01 parsing:08:flatten formula"="12";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="1";"02 preprocessing:08:removing unnecessary predicates"="31";"01 parsing:03:closed world assumption"="26";"02 preprocessing:11:lifted reachabiltiy analysis"="1";"01 parsing:02:sort expansion"="67";"20 search:40:compute heuristic"="54";"01 parsing:00:total"="555";"20 search:10:flaw selector"="2";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="0";"02 preprocessing:01:compile negative preconditions"="19";"20 search:00:total"="217";"00 total:00:total"="1345";"02 preprocessing:12:grounded planning graph analysis"="132";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="65";"20 search:01:flaw estimation"="74";"02 preprocessing:04:split parameter"="14";"01 parsing:05:shop methods"="3";"20 search:02:flaw computation"="19";"10 search preparation:01:compute efficient representation"="113";"01 parsing:06:eliminate identical variables"="5";"02 preprocessing:05:expand choiceless abstract tasks"="31";"03 heuristics preparation:00:total"="1";"02 preprocessing:00:total"="343";"02 preprocessing:99:create artificial top task"="4";"02 preprocessing:84:grounding"="37"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackagPANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 56ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 12ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 8ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774855ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@66cb5d10
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43320728
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1210
============ parsing ============
total                         = 551
file parser                   = 436
sort expansion                = 61
closed world assumption       = 29
inherit preconditions         = 0
shop methods                  = 3
eliminate identical variables = 7
strip domain of hybridity     = 1
flatten formula               = 12
============ preprocessing ============
total                                      = 365
compile negative preconditions             = 25
compile unit methods                       = 1
split parameter                            = 15
expand choiceless abstract tasks           = 23
compile methods with identical tasks       = 0
removing unnecessary predicates            = 35
lifted reachabiltiy analysis               = 0
grounded planning graph analysis           = 146
grounded task decomposition graph analysis = 67
grounding                                  = 41
create artificial top task                 = 2
============ heuristics preparation ============
total = 1
============ search preparation ============
compute efficient representation = 73
============ search ============
total             = 141
flaw estimation   = 39
flaw computation  = 16
flaw selector     = 2
compute heuristic = 27
compute filter    = 0

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43320728";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="436";"01 parsing:08:flatten formula"="12";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="1";"02 preprocessing:08:removing unnecessary predicates"="35";"01 parsing:03:closed world assumption"="29";"02 preprocessing:11:lifted reachabiltiy analysis"="0";"01 parsing:02:sort expansion"="61";"20 search:40:compute heuristic"="27";"01 parsing:00:total"="551";"20 search:10:flaw selector"="2";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="0";"02 preprocessing:01:compile negative preconditions"="25";"20 search:00:total"="141";"00 total:00:total"="1210";"02 preprocessing:12:grounded planning graph analysis"="146";"02 preprocessing:02:compile unit methods"="1";"02 preprocessing:23:grounded task decomposition graph analysis"="67";"20 search:01:flaw estimation"="39";"02 preprocessing:04:split parameter"="15";"01 parsing:05:shop methods"="3";"20 search:02:flaw computation"="16";"10 search preparation:01:compute efficient representation"="73";"01 parsing:06:eliminate identical variables"="7";"02 preprocessing:05:expand choiceless abstract tasks"="23";"03 heuristics preparation:00:total"="1";"02 preprocessing:00:total"="365";"02 preprocessing:99:create artificial top task"="2";"02 preprocessing:84:grounding"="41"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackage1PANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 47ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 15ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 10ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774830ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@65f4c08
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43307736
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1221
============ parsing ============
total                         = 576
file parser                   = 456
sort expansion                = 71
closed world assumption       = 26
inherit preconditions         = 0
shop methods                  = 2
eliminate identical variables = 5
strip domain of hybridity     = 2
flatten formula               = 12
============ preprocessing ============
total                                      = 352
compile negative preconditions             = 22
compile unit methods                       = 0
split parameter                            = 15
expand choiceless abstract tasks           = 26
compile methods with identical tasks       = 0
removing unnecessary predicates            = 30
lifted reachabiltiy analysis               = 0
grounded planning graph analysis           = 138
grounded task decomposition graph analysis = 66
grounding                                  = 40
create artificial top task                 = 4
============ heuristics preparation ============
total = 1
============ search preparation ============
compute efficient representation = 71
============ search ============
total             = 136
flaw estimation   = 42
flaw computation  = 17
flaw selector     = 1
compute heuristic = 29
compute filter    = 0

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43307736";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="456";"01 parsing:08:flatten formula"="12";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="2";"02 preprocessing:08:removing unnecessary predicates"="30";"01 parsing:03:closed world assumption"="26";"02 preprocessing:11:lifted reachabiltiy analysis"="0";"01 parsing:02:sort expansion"="71";"20 search:40:compute heuristic"="29";"01 parsing:00:total"="576";"20 search:10:flaw selector"="1";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="0";"02 preprocessing:01:compile negative preconditions"="22";"20 search:00:total"="136";"00 total:00:total"="1221";"02 preprocessing:12:grounded planning graph analysis"="138";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="66";"20 search:01:flaw estimation"="42";"02 preprocessing:04:split parameter"="15";"01 parsing:05:shop methods"="2";"20 search:02:flaw computation"="17";"10 search preparation:01:compute efficient representation"="71";"01 parsing:06:eliminate identical variables"="5";"02 preprocessing:05:expand choiceless abstract tasks"="26";"03 heuristics preparation:00:total"="1";"02 preprocessing:00:total"="352";"02 preprocessing:99:create artificial top task"="4";"02 preprocessing:84:grounding"="40"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackage1PANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 50ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 12ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 7ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774895ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@5b746e22
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43307800
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1175
============ parsing ============
total                         = 532
file parser                   = 412
sort expansion                = 69
closed world assumption       = 26
inherit preconditions         = 0
shop methods                  = 4
eliminate identical variables = 5
strip domain of hybridity     = 1
flatten formula               = 14
============ preprocessing ============
total                                      = 345
compile negative preconditions             = 17
compile unit methods                       = 0
split parameter                            = 14
expand choiceless abstract tasks           = 23
compile methods with identical tasks       = 0
removing unnecessary predicates            = 35
lifted reachabiltiy analysis               = 0
grounded planning graph analysis           = 138
grounded task decomposition graph analysis = 69
grounding                                  = 37
create artificial top task                 = 3
============ heuristics preparation ============
total = 2
============ search preparation ============
compute efficient representation = 77
============ search ============
total             = 144
flaw estimation   = 46
flaw computation  = 17
flaw selector     = 1
compute heuristic = 30
compute filter    = 0

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43307800";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="412";"01 parsing:08:flatten formula"="14";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="1";"02 preprocessing:08:removing unnecessary predicates"="35";"01 parsing:03:closed world assumption"="26";"02 preprocessing:11:lifted reachabiltiy analysis"="0";"01 parsing:02:sort expansion"="69";"20 search:40:compute heuristic"="30";"01 parsing:00:total"="532";"20 search:10:flaw selector"="1";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="0";"02 preprocessing:01:compile negative preconditions"="17";"20 search:00:total"="144";"00 total:00:total"="1175";"02 preprocessing:12:grounded planning graph analysis"="138";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="69";"20 search:01:flaw estimation"="46";"02 preprocessing:04:split parameter"="14";"01 parsing:05:shop methods"="4";"20 search:02:flaw computation"="17";"10 search preparation:01:compute efficient representation"="77";"01 parsing:06:eliminate identical variables"="5";"02 preprocessing:05:expand choiceless abstract tasks"="23";"03 heuristics preparation:00:total"="2";"02 preprocessing:00:total"="345";"02 preprocessing:99:create artificial top task"="3";"02 preprocessing:84:grounding"="37"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackage1PANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 46ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 12ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 8ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774817ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@2e83a93d
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43301016
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1235
============ parsing ============
total                         = 598
file parser                   = 472
sort expansion                = 72
closed world assumption       = 26
inherit preconditions         = 0
shop methods                  = 3
eliminate identical variables = 5
strip domain of hybridity     = 2
flatten formula               = 16
============ preprocessing ============
total                                      = 355
compile negative preconditions             = 22
compile unit methods                       = 0
split parameter                            = 17
expand choiceless abstract tasks           = 22
compile methods with identical tasks       = 0
removing unnecessary predicates            = 32
lifted reachabiltiy analysis               = 1
grounded planning graph analysis           = 137
grounded task decomposition graph analysis = 68
grounding                                  = 43
create artificial top task                 = 3
============ heuristics preparation ============
total = 1
============ search preparation ============
compute efficient representation = 68
============ search ============
total             = 140
flaw estimation   = 50
flaw computation  = 9
flaw selector     = 1
compute heuristic = 34
compute filter    = 1

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43301016";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="472";"01 parsing:08:flatten formula"="16";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="2";"02 preprocessing:08:removing unnecessary predicates"="32";"01 parsing:03:closed world assumption"="26";"02 preprocessing:11:lifted reachabiltiy analysis"="1";"01 parsing:02:sort expansion"="72";"20 search:40:compute heuristic"="34";"01 parsing:00:total"="598";"20 search:10:flaw selector"="1";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="1";"02 preprocessing:01:compile negative preconditions"="22";"20 search:00:total"="140";"00 total:00:total"="1235";"02 preprocessing:12:grounded planning graph analysis"="137";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="68";"20 search:01:flaw estimation"="50";"02 preprocessing:04:split parameter"="17";"01 parsing:05:shop methods"="3";"20 search:02:flaw computation"="9";"10 search preparation:01:compute efficient representation"="68";"01 parsing:06:eliminate identical variables"="5";"02 preprocessing:05:expand choiceless abstract tasks"="22";"03 heuristics preparation:00:total"="1";"02 preprocessing:00:total"="355";"02 preprocessing:99:create artificial top task"="3";"02 preprocessing:84:grounding"="43"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackage1trPANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 49ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 12ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 8ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774850ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@4b04d9fa
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43309440
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1232
============ parsing ============
total                         = 570
file parser                   = 459
sort expansion                = 63
closed world assumption       = 27
inherit preconditions         = 0
shop methods                  = 2
eliminate identical variables = 5
strip domain of hybridity     = 2
flatten formula               = 12
============ preprocessing ============
total                                      = 351
compile negative preconditions             = 20
compile unit methods                       = 0
split parameter                            = 13
expand choiceless abstract tasks           = 26
compile methods with identical tasks       = 0
removing unnecessary predicates            = 30
lifted reachabiltiy analysis               = 0
grounded planning graph analysis           = 138
grounded task decomposition graph analysis = 70
grounding                                  = 39
create artificial top task                 = 4
============ heuristics preparation ============
total = 1
============ search preparation ============
compute efficient representation = 73
============ search ============
total             = 158
flaw estimation   = 44
flaw computation  = 24
flaw selector     = 2
compute heuristic = 30
compute filter    = 0

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43309440";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="459";"01 parsing:08:flatten formula"="12";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="2";"02 preprocessing:08:removing unnecessary predicates"="30";"01 parsing:03:closed world assumption"="27";"02 preprocessing:11:lifted reachabiltiy analysis"="0";"01 parsing:02:sort expansion"="63";"20 search:40:compute heuristic"="30";"01 parsing:00:total"="570";"20 search:10:flaw selector"="2";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="0";"02 preprocessing:01:compile negative preconditions"="20";"20 search:00:total"="158";"00 total:00:total"="1232";"02 preprocessing:12:grounded planning graph analysis"="138";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="70";"20 search:01:flaw estimation"="44";"02 preprocessing:04:split parameter"="13";"01 parsing:05:shop methods"="2";"20 search:02:flaw computation"="24";"10 search preparation:01:compute efficient representation"="73";"01 parsing:06:eliminate identical variables"="5";"02 preprocessing:05:expand choiceless abstract tasks"="26";"03 heuristics preparation:00:total"="1";"02 preprocessing:00:total"="351";"02 preprocessing:99:create artificial top task"="4";"02 preprocessing:84:grounding"="39"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackage1PANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 67ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 14ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 8ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774536ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@65f4c08
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43310848
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1650
============ parsing ============
total                         = 809
file parser                   = 621
sort expansion                = 95
closed world assumption       = 48
inherit preconditions         = 0
shop methods                  = 5
eliminate identical variables = 10
strip domain of hybridity     = 3
flatten formula               = 23
============ preprocessing ============
total                                      = 418
compile negative preconditions             = 30
compile unit methods                       = 0
split parameter                            = 17
expand choiceless abstract tasks           = 31
compile methods with identical tasks       = 0
removing unnecessary predicates            = 34
lifted reachabiltiy analysis               = 1
grounded planning graph analysis           = 177
grounded task decomposition graph analysis = 70
grounding                                  = 42
create artificial top task                 = 4
============ heuristics preparation ============
total = 0
============ search preparation ============
compute efficient representation = 73
============ search ============
total             = 249
flaw estimation   = 58
flaw computation  = 29
flaw selector     = 5
compute heuristic = 66
compute filter    = 0

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43310848";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="621";"01 parsing:08:flatten formula"="23";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="3";"02 preprocessing:08:removing unnecessary predicates"="34";"01 parsing:03:closed world assumption"="48";"02 preprocessing:11:lifted reachabiltiy analysis"="1";"01 parsing:02:sort expansion"="95";"20 search:40:compute heuristic"="66";"01 parsing:00:total"="809";"20 search:10:flaw selector"="5";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="0";"02 preprocessing:01:compile negative preconditions"="30";"20 search:00:total"="249";"00 total:00:total"="1650";"02 preprocessing:12:grounded planning graph analysis"="177";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="70";"20 search:01:flaw estimation"="58";"02 preprocessing:04:split parameter"="17";"01 parsing:05:shop methods"="5";"20 search:02:flaw computation"="29";"10 search preparation:01:compute efficient representation"="73";"01 parsing:06:eliminate identical variables"="10";"02 preprocessing:05:expand choiceless abstract tasks"="31";"03 heuristics preparation:00:total"="0";"02 preprocessing:00:total"="418";"02 preprocessing:99:create artificial top task"="4";"02 preprocessing:84:grounding"="42"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackagePANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 48ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 13ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 10ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774829ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@4739b68b
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43342344
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1228
============ parsing ============
total                         = 570
file parser                   = 457
sort expansion                = 61
closed world assumption       = 30
inherit preconditions         = 0
shop methods                  = 2
eliminate identical variables = 5
strip domain of hybridity     = 1
flatten formula               = 12
============ preprocessing ============
total                                      = 370
compile negative preconditions             = 20
compile unit methods                       = 0
split parameter                            = 14
expand choiceless abstract tasks           = 23
compile methods with identical tasks       = 0
removing unnecessary predicates            = 32
lifted reachabiltiy analysis               = 0
grounded planning graph analysis           = 142
grounded task decomposition graph analysis = 77
grounding                                  = 46
create artificial top task                 = 3
============ heuristics preparation ============
total = 1
============ search preparation ============
compute efficient representation = 69
============ search ============
total             = 137
flaw estimation   = 44
flaw computation  = 14
flaw selector     = 3
compute heuristic = 38
compute filter    = 1

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43342344";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="457";"01 parsing:08:flatten formula"="12";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="1";"02 preprocessing:08:removing unnecessary predicates"="32";"01 parsing:03:closed world assumption"="30";"02 preprocessing:11:lifted reachabiltiy analysis"="0";"01 parsing:02:sort expansion"="61";"20 search:40:compute heuristic"="38";"01 parsing:00:total"="570";"20 search:10:flaw selector"="3";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="1";"02 preprocessing:01:compile negative preconditions"="20";"20 search:00:total"="137";"00 total:00:total"="1228";"02 preprocessing:12:grounded planning graph analysis"="142";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="77";"20 search:01:flaw estimation"="44";"02 preprocessing:04:split parameter"="14";"01 parsing:05:shop methods"="2";"20 search:02:flaw computation"="14";"10 search preparation:01:compute efficient representation"="69";"01 parsing:06:eliminate identical variables"="5";"02 preprocessing:05:expand choiceless abstract tasks"="23";"03 heuristics preparation:00:total"="1";"02 preprocessing:00:total"="370";"02 preprocessing:99:create artificial top task"="3";"02 preprocessing:84:grounding"="46"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackagePANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 48ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 15ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 8ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774816ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@593e685
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43308720
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1245
============ parsing ============
total                         = 570
file parser                   = 444
sort expansion                = 76
closed world assumption       = 26
inherit preconditions         = 0
shop methods                  = 3
eliminate identical variables = 5
strip domain of hybridity     = 2
flatten formula               = 13
============ preprocessing ============
total                                      = 386
compile negative preconditions             = 19
compile unit methods                       = 0
split parameter                            = 15
expand choiceless abstract tasks           = 32
compile methods with identical tasks       = 0
removing unnecessary predicates            = 30
lifted reachabiltiy analysis               = 0
grounded planning graph analysis           = 150
grounded task decomposition graph analysis = 77
grounding                                  = 48
create artificial top task                 = 3
============ heuristics preparation ============
total = 2
============ search preparation ============
compute efficient representation = 68
============ search ============
total             = 141
flaw estimation   = 48
flaw computation  = 14
flaw selector     = 0
compute heuristic = 35
compute filter    = 0

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43308720";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="444";"01 parsing:08:flatten formula"="13";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="2";"02 preprocessing:08:removing unnecessary predicates"="30";"01 parsing:03:closed world assumption"="26";"02 preprocessing:11:lifted reachabiltiy analysis"="0";"01 parsing:02:sort expansion"="76";"20 search:40:compute heuristic"="35";"01 parsing:00:total"="570";"20 search:10:flaw selector"="0";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="0";"02 preprocessing:01:compile negative preconditions"="19";"20 search:00:total"="141";"00 total:00:total"="1245";"02 preprocessing:12:grounded planning graph analysis"="150";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="77";"20 search:01:flaw estimation"="48";"02 preprocessing:04:split parameter"="15";"01 parsing:05:shop methods"="3";"20 search:02:flaw computation"="14";"10 search preparation:01:compute efficient representation"="68";"01 parsing:06:eliminate identical variables"="5";"02 preprocessing:05:expand choiceless abstract tasks"="32";"03 heuristics preparation:00:total"="2";"02 preprocessing:00:total"="386";"02 preprocessing:99:create artificial top task"="3";"02 preprocessing:84:grounding"="48"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackage1tPANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 102ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 17ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 10ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774599ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@4bd5d645
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43307176
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1469
============ parsing ============
total                         = 588
file parser                   = 464
sort expansion                = 66
closed world assumption       = 29
inherit preconditions         = 0
shop methods                  = 3
eliminate identical variables = 8
strip domain of hybridity     = 2
flatten formula               = 16
============ preprocessing ============
total                                      = 566
compile negative preconditions             = 22
compile unit methods                       = 0
split parameter                            = 18
expand choiceless abstract tasks           = 30
compile methods with identical tasks       = 0
removing unnecessary predicates            = 32
lifted reachabiltiy analysis               = 1
grounded planning graph analysis           = 309
grounded task decomposition graph analysis = 83
grounding                                  = 54
create artificial top task                 = 5
============ heuristics preparation ============
total = 2
============ search preparation ============
compute efficient representation = 77
============ search ============
total             = 139
flaw estimation   = 52
flaw computation  = 18
flaw selector     = 1
compute heuristic = 22
compute filter    = 0

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43307176";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="464";"01 parsing:08:flatten formula"="16";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="2";"02 preprocessing:08:removing unnecessary predicates"="32";"01 parsing:03:closed world assumption"="29";"02 preprocessing:11:lifted reachabiltiy analysis"="1";"01 parsing:02:sort expansion"="66";"20 search:40:compute heuristic"="22";"01 parsing:00:total"="588";"20 search:10:flaw selector"="1";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="0";"02 preprocessing:01:compile negative preconditions"="22";"20 search:00:total"="139";"00 total:00:total"="1469";"02 preprocessing:12:grounded planning graph analysis"="309";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="83";"20 search:01:flaw estimation"="52";"02 preprocessing:04:split parameter"="18";"01 parsing:05:shop methods"="3";"20 search:02:flaw computation"="18";"10 search preparation:01:compute efficient representation"="77";"01 parsing:06:eliminate identical variables"="8";"02 preprocessing:05:expand choiceless abstract tasks"="30";"03 heuristics preparation:00:total"="2";"02 preprocessing:00:total"="566";"02 preprocessing:99:create artificial top task"="5";"02 preprocessing:84:grounding"="54"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackagPANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 45ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 13ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 9ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774880ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@6b30f2c
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43333256
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1173
============ parsing ============
total                         = 526
file parser                   = 414
sort expansion                = 65
closed world assumption       = 26
inherit preconditions         = 0
shop methods                  = 3
eliminate identical variables = 5
strip domain of hybridity     = 1
flatten formula               = 12
============ preprocessing ============
total                                      = 350
compile negative preconditions             = 20
compile unit methods                       = 0
split parameter                            = 14
expand choiceless abstract tasks           = 26
compile methods with identical tasks       = 0
removing unnecessary predicates            = 34
lifted reachabiltiy analysis               = 0
grounded planning graph analysis           = 140
grounded task decomposition graph analysis = 67
grounding                                  = 37
create artificial top task                 = 4
============ heuristics preparation ============
total = 2
============ search preparation ============
compute efficient representation = 70
============ search ============
total             = 133
flaw estimation   = 45
flaw computation  = 13
flaw selector     = 3
compute heuristic = 28
compute filter    = 0

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43333256";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="414";"01 parsing:08:flatten formula"="12";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="1";"02 preprocessing:08:removing unnecessary predicates"="34";"01 parsing:03:closed world assumption"="26";"02 preprocessing:11:lifted reachabiltiy analysis"="0";"01 parsing:02:sort expansion"="65";"20 search:40:compute heuristic"="28";"01 parsing:00:total"="526";"20 search:10:flaw selector"="3";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="0";"02 preprocessing:01:compile negative preconditions"="20";"20 search:00:total"="133";"00 total:00:total"="1173";"02 preprocessing:12:grounded planning graph analysis"="140";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="67";"20 search:01:flaw estimation"="45";"02 preprocessing:04:split parameter"="14";"01 parsing:05:shop methods"="3";"20 search:02:flaw computation"="13";"10 search preparation:01:compute efficient representation"="70";"01 parsing:06:eliminate identical variables"="5";"02 preprocessing:05:expand choiceless abstract tasks"="26";"03 heuristics preparation:00:total"="2";"02 preprocessing:00:total"="350";"02 preprocessing:99:create artificial top task"="4";"02 preprocessing:84:grounding"="37"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackage1tPANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 43ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 13ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 8ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774874ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@5581a12f
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43319528
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1200
============ parsing ============
total                         = 525
file parser                   = 397
sort expansion                = 71
closed world assumption       = 28
inherit preconditions         = 0
shop methods                  = 4
eliminate identical variables = 5
strip domain of hybridity     = 2
flatten formula               = 17
============ preprocessing ============
total                                      = 366
compile negative preconditions             = 20
compile unit methods                       = 0
split parameter                            = 18
expand choiceless abstract tasks           = 23
compile methods with identical tasks       = 0
removing unnecessary predicates            = 32
lifted reachabiltiy analysis               = 0
grounded planning graph analysis           = 137
grounded task decomposition graph analysis = 67
grounding                                  = 56
create artificial top task                 = 4
============ heuristics preparation ============
total = 0
============ search preparation ============
compute efficient representation = 72
============ search ============
total             = 154
flaw estimation   = 58
flaw computation  = 16
flaw selector     = 5
compute heuristic = 29
compute filter    = 0

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43319528";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="397";"01 parsing:08:flatten formula"="17";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="2";"02 preprocessing:08:removing unnecessary predicates"="32";"01 parsing:03:closed world assumption"="28";"02 preprocessing:11:lifted reachabiltiy analysis"="0";"01 parsing:02:sort expansion"="71";"20 search:40:compute heuristic"="29";"01 parsing:00:total"="525";"20 search:10:flaw selector"="5";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="0";"02 preprocessing:01:compile negative preconditions"="20";"20 search:00:total"="154";"00 total:00:total"="1200";"02 preprocessing:12:grounded planning graph analysis"="137";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="67";"20 search:01:flaw estimation"="58";"02 preprocessing:04:split parameter"="18";"01 parsing:05:shop methods"="4";"20 search:02:flaw computation"="16";"10 search preparation:01:compute efficient representation"="72";"01 parsing:06:eliminate identical variables"="5";"02 preprocessing:05:expand choiceless abstract tasks"="23";"03 heuristics preparation:00:total"="0";"02 preprocessing:00:total"="366";"02 preprocessing:99:create artificial top task"="4";"02 preprocessing:84:grounding"="56"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackage1PANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 45ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 15ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 8ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774878ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@66cb5d10
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43311384
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1174
============ parsing ============
total                         = 541
file parser                   = 418
sort expansion                = 62
closed world assumption       = 37
inherit preconditions         = 0
shop methods                  = 3
eliminate identical variables = 7
strip domain of hybridity     = 1
flatten formula               = 10
============ preprocessing ============
total                                      = 350
compile negative preconditions             = 20
compile unit methods                       = 0
split parameter                            = 17
expand choiceless abstract tasks           = 24
compile methods with identical tasks       = 0
removing unnecessary predicates            = 32
lifted reachabiltiy analysis               = 1
grounded planning graph analysis           = 136
grounded task decomposition graph analysis = 65
grounding                                  = 41
create artificial top task                 = 3
============ heuristics preparation ============
total = 0
============ search preparation ============
compute efficient representation = 68
============ search ============
total             = 141
flaw estimation   = 42
flaw computation  = 14
flaw selector     = 1
compute heuristic = 36
compute filter    = 1

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43311384";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="418";"01 parsing:08:flatten formula"="10";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="1";"02 preprocessing:08:removing unnecessary predicates"="32";"01 parsing:03:closed world assumption"="37";"02 preprocessing:11:lifted reachabiltiy analysis"="1";"01 parsing:02:sort expansion"="62";"20 search:40:compute heuristic"="36";"01 parsing:00:total"="541";"20 search:10:flaw selector"="1";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="1";"02 preprocessing:01:compile negative preconditions"="20";"20 search:00:total"="141";"00 total:00:total"="1174";"02 preprocessing:12:grounded planning graph analysis"="136";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="65";"20 search:01:flaw estimation"="42";"02 preprocessing:04:split parameter"="17";"01 parsing:05:shop methods"="3";"20 search:02:flaw computation"="14";"10 search preparation:01:compute efficient representation"="68";"01 parsing:06:eliminate identical variables"="7";"02 preprocessing:05:expand choiceless abstract tasks"="24";"03 heuristics preparation:00:total"="0";"02 preprocessing:00:total"="350";"02 preprocessing:99:create artificial top task"="3";"02 preprocessing:84:grounding"="41"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackage1PANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 51ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 12ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 10ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774857ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@6b30f2c
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43297288
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1198
============ parsing ============
total                         = 543
file parser                   = 421
sort expansion                = 64
closed world assumption       = 30
inherit preconditions         = 0
shop methods                  = 6
eliminate identical variables = 5
strip domain of hybridity     = 2
flatten formula               = 14
============ preprocessing ============
total                                      = 367
compile negative preconditions             = 20
compile unit methods                       = 0
split parameter                            = 15
expand choiceless abstract tasks           = 22
compile methods with identical tasks       = 0
removing unnecessary predicates            = 29
lifted reachabiltiy analysis               = 0
grounded planning graph analysis           = 145
grounded task decomposition graph analysis = 73
grounding                                  = 50
create artificial top task                 = 3
============ heuristics preparation ============
total = 1
============ search preparation ============
compute efficient representation = 67
============ search ============
total             = 139
flaw estimation   = 46
flaw computation  = 12
flaw selector     = 2
compute heuristic = 30
compute filter    = 0

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43297288";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="421";"01 parsing:08:flatten formula"="14";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="2";"02 preprocessing:08:removing unnecessary predicates"="29";"01 parsing:03:closed world assumption"="30";"02 preprocessing:11:lifted reachabiltiy analysis"="0";"01 parsing:02:sort expansion"="64";"20 search:40:compute heuristic"="30";"01 parsing:00:total"="543";"20 search:10:flaw selector"="2";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="0";"02 preprocessing:01:compile negative preconditions"="20";"20 search:00:total"="139";"00 total:00:total"="1198";"02 preprocessing:12:grounded planning graph analysis"="145";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="73";"20 search:01:flaw estimation"="46";"02 preprocessing:04:split parameter"="15";"01 parsing:05:shop methods"="6";"20 search:02:flaw computation"="12";"10 search preparation:01:compute efficient representation"="67";"01 parsing:06:eliminate identical variables"="5";"02 preprocessing:05:expand choiceless abstract tasks"="22";"03 heuristics preparation:00:total"="1";"02 preprocessing:00:total"="367";"02 preprocessing:99:create artificial top task"="3";"02 preprocessing:84:grounding"="50"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackage1PANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 54ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 15ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 8ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774833ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@4739b68b
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43299528
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1233
============ parsing ============
total                         = 537
file parser                   = 414
sort expansion                = 64
closed world assumption       = 31
inherit preconditions         = 0
shop methods                  = 3
eliminate identical variables = 7
strip domain of hybridity     = 2
flatten formula               = 16
============ preprocessing ============
total                                      = 401
compile negative preconditions             = 23
compile unit methods                       = 0
split parameter                            = 15
expand choiceless abstract tasks           = 35
compile methods with identical tasks       = 0
removing unnecessary predicates            = 37
lifted reachabiltiy analysis               = 0
grounded planning graph analysis           = 150
grounded task decomposition graph analysis = 75
grounding                                  = 50
create artificial top task                 = 4
============ heuristics preparation ============
total = 0
============ search preparation ============
compute efficient representation = 69
============ search ============
total             = 152
flaw estimation   = 50
flaw computation  = 12
flaw selector     = 2
compute heuristic = 40
compute filter    = 0

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43299528";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="414";"01 parsing:08:flatten formula"="16";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="2";"02 preprocessing:08:removing unnecessary predicates"="37";"01 parsing:03:closed world assumption"="31";"02 preprocessing:11:lifted reachabiltiy analysis"="0";"01 parsing:02:sort expansion"="64";"20 search:40:compute heuristic"="40";"01 parsing:00:total"="537";"20 search:10:flaw selector"="2";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="0";"02 preprocessing:01:compile negative preconditions"="23";"20 search:00:total"="152";"00 total:00:total"="1233";"02 preprocessing:12:grounded planning graph analysis"="150";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="75";"20 search:01:flaw estimation"="50";"02 preprocessing:04:split parameter"="15";"01 parsing:05:shop methods"="3";"20 search:02:flaw computation"="12";"10 search preparation:01:compute efficient representation"="69";"01 parsing:06:eliminate identical variables"="7";"02 preprocessing:05:expand choiceless abstract tasks"="35";"03 heuristics preparation:00:total"="0";"02 preprocessing:00:total"="401";"02 preprocessing:99:create artificial top task"="4";"02 preprocessing:84:grounding"="50"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackage1PANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 44ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 22ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 8ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774812ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@4bd5d645
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43305968
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1251
============ parsing ============
total                         = 600
file parser                   = 486
sort expansion                = 65
closed world assumption       = 28
inherit preconditions         = 0
shop methods                  = 3
eliminate identical variables = 5
strip domain of hybridity     = 1
flatten formula               = 11
============ preprocessing ============
total                                      = 359
compile negative preconditions             = 19
compile unit methods                       = 0
split parameter                            = 14
expand choiceless abstract tasks           = 23
compile methods with identical tasks       = 0
removing unnecessary predicates            = 39
lifted reachabiltiy analysis               = 0
grounded planning graph analysis           = 143
grounded task decomposition graph analysis = 69
grounding                                  = 38
create artificial top task                 = 4
============ heuristics preparation ============
total = 1
============ search preparation ============
compute efficient representation = 69
============ search ============
total             = 150
flaw estimation   = 52
flaw computation  = 14
flaw selector     = 2
compute heuristic = 32
compute filter    = 0

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43305968";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="486";"01 parsing:08:flatten formula"="11";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="1";"02 preprocessing:08:removing unnecessary predicates"="39";"01 parsing:03:closed world assumption"="28";"02 preprocessing:11:lifted reachabiltiy analysis"="0";"01 parsing:02:sort expansion"="65";"20 search:40:compute heuristic"="32";"01 parsing:00:total"="600";"20 search:10:flaw selector"="2";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="0";"02 preprocessing:01:compile negative preconditions"="19";"20 search:00:total"="150";"00 total:00:total"="1251";"02 preprocessing:12:grounded planning graph analysis"="143";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="69";"20 search:01:flaw estimation"="52";"02 preprocessing:04:split parameter"="14";"01 parsing:05:shop methods"="3";"20 search:02:flaw computation"="14";"10 search preparation:01:compute efficient representation"="69";"01 parsing:06:eliminate identical variables"="5";"02 preprocessing:05:expand choiceless abstract tasks"="23";"03 heuristics preparation:00:total"="1";"02 preprocessing:00:total"="359";"02 preprocessing:99:create artificial top task"="4";"02 preprocessing:84:grounding"="38"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackage1PANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 50ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 16ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 8ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774847ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@66cb5d10
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43327472
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1222
============ parsing ============
total                         = 553
file parser                   = 437
sort expansion                = 66
closed world assumption       = 26
inherit preconditions         = 0
shop methods                  = 3
eliminate identical variables = 5
strip domain of hybridity     = 1
flatten formula               = 13
============ preprocessing ============
total                                      = 369
compile negative preconditions             = 19
compile unit methods                       = 0
split parameter                            = 14
expand choiceless abstract tasks           = 28
compile methods with identical tasks       = 0
removing unnecessary predicates            = 35
lifted reachabiltiy analysis               = 0
grounded planning graph analysis           = 149
grounded task decomposition graph analysis = 72
grounding                                  = 40
create artificial top task                 = 3
============ heuristics preparation ============
total = 2
============ search preparation ============
compute efficient representation = 69
============ search ============
total             = 156
flaw estimation   = 54
flaw computation  = 16
flaw selector     = 4
compute heuristic = 21
compute filter    = 0

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43327472";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="437";"01 parsing:08:flatten formula"="13";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="1";"02 preprocessing:08:removing unnecessary predicates"="35";"01 parsing:03:closed world assumption"="26";"02 preprocessing:11:lifted reachabiltiy analysis"="0";"01 parsing:02:sort expansion"="66";"20 search:40:compute heuristic"="21";"01 parsing:00:total"="553";"20 search:10:flaw selector"="4";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="0";"02 preprocessing:01:compile negative preconditions"="19";"20 search:00:total"="156";"00 total:00:total"="1222";"02 preprocessing:12:grounded planning graph analysis"="149";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="72";"20 search:01:flaw estimation"="54";"02 preprocessing:04:split parameter"="14";"01 parsing:05:shop methods"="3";"20 search:02:flaw computation"="16";"10 search preparation:01:compute efficient representation"="69";"01 parsing:06:eliminate identical variables"="5";"02 preprocessing:05:expand choiceless abstract tasks"="28";"03 heuristics preparation:00:total"="2";"02 preprocessing:00:total"="369";"02 preprocessing:99:create artificial top task"="3";"02 preprocessing:84:grounding"="40"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackage1PANDA - Planning and Acting in a Network Decomposition Architecture
Believe us: It's great, it's fantastic!

PANDA Copyright (C) 2014-2018 Gregor Behnke, Pascal Bercher, Thomas Geier, Kadir
Dede, Daniel Höller, Kristof Mickeleit, Matthias Englert
This program comes with ABSOLUTELY NO WARRANTY
This is free software, and you are welcome to redistribute it under certain
conditions; run PANDA with -license for details.

Main Developers:
- Gregor Behnke, http://www.uni-ulm.de/in/ki/behnke
- Daniel Höller, http://www.uni-ulm.de/in/ki/hoeller

With many thanks to various further contributors.
Run PANDA with the command line argument -contributors for an extensive list.

Run it with -help for more information like available options.


PANDA was called with: "Output/domain1.hddl Output/problem1-p.hddl -systemConfig makespan-astar -outputPlan"


Planner Configuration
=====================
Domain: Output/domain1.hddl
Problem: Output/problem1-p.hddl
Output: none

Planning Configuration
======================
	printGeneralInformation : true
	printAdditionalData     : true
	random seed             : 42
	time limit (in seconds) : none

	external programs:


	Parsing Configuration
	---------------------
	Parser                : autodetect file-type
	Expand Sort Hierarchy : true
	ClosedWordAssumption  : true
	CompileSHOPMethods    : true
	Eliminate Equality    : true
	Strip Hybridity       : true
	Reduce General Tasks  : true
	
	Preprocessing Configuration
	---------------------------
	Compile negative preconditions    : true
	Compile unit methods              : false
	Compile order in methods          : false
	Compile initial plan              : true
	Ensure Methods Have Last Task     : false
	Split independent parameters      : true
	Remove unnecessary predicates     : true
	Expand choiceless abstract tasks  : true
	Domain Cleanup                    : true
	Convert to SAS+                   : false
	Grounded Reachability Analysis    : Planning Graph (mutex-free)
	Grounded Task Decomposition Graph : Two Way TDG
	Iterate reachability analysis     : true
	Ground domain                     : true
	Iterate reachability analysis     : true
	Stop directly after grounding     : false
	
	Plan-based Search Configuration
	-------------------------------
	Node limit           : none
	Search Algorithm     : A*-Makespan
	Heuristic            : none
	Flaw selector        : lcfr
	Pruning              : off
	Efficient search     : true
	Continue on solution : false
	Print search info    : true
	
	Post-processing Configuration
	-----------------------------
	search status
	search result
	timings
	statistics
#0 "00 global:01:problem"="problem1-p.hddl";"00 global:00:domain"="domain1.hddl"
Parsing domain ... using HDDL parser ... done
Preparing internal domain representation ... done.
Initial domain
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 31
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling negative preconditions ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Compiling split parameters ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 62
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 45ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 2
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 1
Grounding ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 13ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Omitting lifted reachability analysis ... 
Grounded planning graph ... done in 8ms.
	Number of Grounded Actions 21
	Number of Grounded Literals 50
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Two Way TDG ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling expand choiceless abstract tasks ... done.
	number of abstract tasks = 0
	number of tasks = 21
	number of decomposition methods = 0
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = -1
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Compiling initial plan ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Removing unnecessary predicates ... done.
	number of abstract tasks = 1
	number of tasks = 22
	number of decomposition methods = 1
	number of predicates = 50
	number of sorts = 0
	number of tasks in largest method = 21
	number of primitive SHOP tasks = 0
	number of epsilon methods = 0
	number of primitive tasks = 21
	number of constants = 0
Tasks 21 - 0
Domain is acyclic: true
Domain is mostly acyclic: true
Domain is regular: true
Domain is tail recursive: true
Domain is totally ordered: false
Domain has last task in all methods: false
Time remaining for planner 9223372036854774848ms
Found new lowest heuristic value: 2.0 @ plan #0
Found solution at depth 69 with 21 actions and heuristic [D@74fd38e
Panda says: SOLUTION
============ global ============
randomseed     = 42
peak memory    = 43300808
planner result = SOLUTION
============ solution ============
number of primitive plan steps = 21
============ properties ============
acyclic                  = true
mostly acyclic           = true
regular                  = true
tail recursive           = true
totally ordered          = false
last task in all methods = false
============ search nodes ============
total    = 159
expanded = 139
============ search plans ============
number of plansteps-mean = 22.87421383647799
============ problem ============
number of constants                  = 0
number of predicates                 = 50
number of actions                    = 22
number of abstract actions           = 1
number of primitive actions          = 21
number of methods                    = 1
number of primitive shop actions     = 0
number of primitive non-shop actions = 21
size of largest method               = 21
average method size                  = 21

----------------- TIMINGS -----------------
============ total ============
total = 1217
============ parsing ============
total                         = 552
file parser                   = 422
sort expansion                = 81
closed world assumption       = 26
inherit preconditions         = 0
shop methods                  = 3
eliminate identical variables = 5
strip domain of hybridity     = 2
flatten formula               = 12
============ preprocessing ============
total                                      = 367
compile negative preconditions             = 18
compile unit methods                       = 0
split parameter                            = 14
expand choiceless abstract tasks           = 25
compile methods with identical tasks       = 0
removing unnecessary predicates            = 33
lifted reachabiltiy analysis               = 1
grounded planning graph analysis           = 139
grounded task decomposition graph analysis = 77
grounding                                  = 49
create artificial top task                 = 3
============ heuristics preparation ============
total = 1
============ search preparation ============
compute efficient representation = 74
============ search ============
total             = 135
flaw estimation   = 45
flaw computation  = 13
flaw selector     = 1
compute heuristic = 32
compute filter    = 0

#1 "30 problem:05:number of primitive actions"="21";"10 search nodes:01:expanded"="139";"30 problem:01:number of constants"="0";"30 problem:04:number of abstract actions"="1";"02 properties:04:tail recursive"="true";"00 global:80:peak memory"="43300808";"02 properties:02:mostly acyclic"="true";"30 problem:06:number of methods"="1";"30 problem:07:number of primitive shop actions"="0";"01 solution:01:number of primitive plan steps"="21";"02 properties:05:totally ordered"="false";"10 search nodes:00:total"="159";"02 properties:06:last task in all methods"="false";"30 problem:03:number of actions"="22";"30 problem:08:number of primitive non-shop actions"="21";"30 problem:02:number of predicates"="50";"30 problem:10:average method size"="21";"02 properties:03:regular"="true";"30 problem:09:size of largest method"="21";"00 global:90:planner result"="SOLUTION";"02 properties:01:acyclic"="true";"20 search plans:01:number of plansteps-mean"="22.87421383647799";"00 global:02:randomseed"="42";"01 parsing:01:file parser"="422";"01 parsing:08:flatten formula"="12";"02 preprocessing:07:compile methods with identical tasks"="0";"01 parsing:07:strip domain of hybridity"="2";"02 preprocessing:08:removing unnecessary predicates"="33";"01 parsing:03:closed world assumption"="26";"02 preprocessing:11:lifted reachabiltiy analysis"="1";"01 parsing:02:sort expansion"="81";"20 search:40:compute heuristic"="32";"01 parsing:00:total"="552";"20 search:10:flaw selector"="1";"01 parsing:04:inherit preconditions"="0";"20 search:50:compute filter"="0";"02 preprocessing:01:compile negative preconditions"="18";"20 search:00:total"="135";"00 total:00:total"="1217";"02 preprocessing:12:grounded planning graph analysis"="139";"02 preprocessing:02:compile unit methods"="0";"02 preprocessing:23:grounded task decomposition graph analysis"="77";"20 search:01:flaw estimation"="45";"02 preprocessing:04:split parameter"="14";"01 parsing:05:shop methods"="3";"20 search:02:flaw computation"="13";"10 search preparation:01:compute efficient representation"="74";"01 parsing:06:eliminate identical variables"="5";"02 preprocessing:05:expand choiceless abstract tasks"="25";"03 heuristics preparation:00:total"="1";"02 preprocessing:00:total"="367";"02 preprocessing:99:create artificial top task"="3";"02 preprocessing:84:grounding"="49"
SOLUTION SEQUENCE, Makespan: 11
0: LOAD-TRUCKpackage3truck2s4()
1: LOAD-TRUCKpackage2truck1s0()
2: LOAD-TRUCKpackage4truck2s4()
3: BOARD-TRUCKdriver1truck2s4()
4: DRIVE-TRUCKtruck2s4s1driver1()
5: BOARD-TRUCKdriver2truck1s0()
6: LOAD-TRUCKpackage1truck2s1()
7: DRIVE-TRUCKtruck1s0s1driver2()
8: UNLOAD-TRUCKpackage2truck1s1()
9: DRIVE-TRUCKtruck1s1s0driver2()
10: DISEMBARK-TRUCKdriver2truck1s0()
11: DRIVE-TRUCKtruck2s1s4driver1()
12: LOAD-TRUCKpackage5truck2s4()
13: DRIVE-TRUCKtruck2s4s5driver1()
14: UNLOAD-TRUCKpackage3truck2s5()
15: UNLOAD-TRUCKpackage1truck2s5()
16: DRIVE-TRUCKtruck2s5s3driver1()
17: UNLOAD-TRUCKpackage5truck2s3()
18: DRIVE-TRUCKtruck2s3s1driver1()
19: DISEMBARK-TRUCKdriver1truck2s1()
20: UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s5s3driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage1truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> LOAD-TRUCKpackage5truck2s4()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s3s1driver1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage4truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage5truck2s3()
DRIVE-TRUCKtruck2s1s4driver1() -> UNLOAD-TRUCKpackage3truck2s5()
DRIVE-TRUCKtruck2s1s4driver1() -> DISEMBARK-TRUCKdriver1truck2s1()
DRIVE-TRUCKtruck2s1s4driver1() -> DRIVE-TRUCKtruck2s4s5driver1()
DRIVE-TRUCKtruck1s0s1driver2() -> DISEMBARK-TRUCKdriver2truck1s0()
DRIVE-TRUCKtruck1s0s1driver2() -> DRIVE-TRUCKtruck1s1s0driver2()
DRIVE-TRUCKtruck1s0s1driver2() -> UNLOAD-TRUCKpackage2truck1s1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s1s4driver1()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s5s3driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage1truck2s5()
LOAD-TRUCKpackage1truck2s1() -> LOAD-TRUCKpackage5truck2s4()
LOAD-TRUCKpackage1truck2s1() -> DRIVE-TRUCKtruck2s3s1driver1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage4truck2s1()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage5truck2s3()
LOAD-TRUCKpackage1truck2s1() -> UNLOAD-TRUCKpackage3truck2s5()
LOAD-TRUCKpackage1truck2s1() -> DISEMBARK-TRUCKdriver1truck2s1()
LOAD-TRUCKpackage1t